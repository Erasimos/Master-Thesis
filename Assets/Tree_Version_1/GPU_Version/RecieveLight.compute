// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ReceiveLight
#include "../../Shaders/Random.cginc"
#include "ComputeTreeInclude.cginc"

uniform int batch;
uniform float4x4 depthMVP;

uniform RWStructuredBuffer<int1x3> branch_parent_main_lateral;
uniform RWStructuredBuffer<float3> branch_bottom;
uniform RWStructuredBuffer<float3> branch_top;
uniform RWStructuredBuffer<float> branch_gath_energy;
uniform RWStructuredBuffer<float> branch_dist_energy;
uniform RWStructuredBuffer<int> free_idxs;

uniform RWTexture2D<float> shadowMapTexture;

bool isTerminal(int branch_index)
{
    return branch_parent_main_lateral[branch_index]._12 == -1 && branch_parent_main_lateral[branch_index]._13 == -1;
}

bool isDead(int branch_index)
{
    return branch_parent_main_lateral[branch_index]._11 == -1;
}

float GetShadowValue(float3 pos)
{
    float4 samplePos = mul(depthMVP, float4(pos, 1));
    if (shadowMapTexture[samplePos.xy].r < samplePos.z)
        return 1;
    else
        return 0;
}

float EvaluateLight(float3 pos)
{
    // TODO FOR MULTIPLE SHADOWMAPS
    return 1 - GetShadowValue(pos);
}

[numthreads(batch_size, 1, 1)]
void ReceiveLight (uint3 id : SV_DispatchThreadID)
{
    int branch_index = id.x + batch * batch_size;
    
    if (isDead(branch_index))
    {
        return;
    }
    
    if (isTerminal(branch_index))
    {
        branch_gath_energy[branch_index] = EvaluateLight(branch_top[branch_index]);
    }
                
}
